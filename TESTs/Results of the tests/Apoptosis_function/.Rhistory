k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend("top", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
}
ave_plot(data_out = data_out, output = "N", lg = "Number of cells", xl = c(0,75), yl = c(0,1700))
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
tck_w <- 0.03
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend("top", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
mT  <- max(data_out$Time)
mRP <- max(data_out$Repeat_number)
tck_w <- 0.03
par(cex.axis=1.3, cex.lab=1.6, cex=1.4, mar=c(5.1, 4.1, 4.1, 2.1), mgp=c(2.3, 0.3, 0),xpd=TRUE, tck = tck_w,font.lab = 2)
d_out <- data_out[[output]]
output = "N"
lg = "Number of cells"
xl = c(0,75)
yl = c(0,1800)
tck_w <- 0.03
par(cex.axis=1.3, cex.lab=1.6, cex=1.4, mar=c(5.1, 4.1, 4.1, 2.1), mgp=c(2.3, 0.3, 0),xpd=TRUE, tck = tck_w,font.lab = 2)
d_out <- data_out[[output]]
# plot(data_out$Time,d_out,type = "p",cex = 0.2)
if (  sum(d_out) == 0) { stop("There are all zero data, please, check input data !") }
data_ave <- matrix(data = 0, ncol = 2,nrow = mT + 1)
for (k in 1:(mT+1)  ) {
data_ave[k,1] = k-1
n <- which(data_out$Time == (k-1) )
data_ave[k,2] = sum(d_out[n]) / mRP
}
plot(data_out$Time,d_out,type = "p",cex = 0.15, xlab = "Time step", ylab = lg, xlim = xl, ylim = yl)
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lwd = 3, col = "red", add = TRUE)
legend("top", c("100 simulations", "average value"), bty = "n", col = c("black","red"),
lty = c(NA,1),pch = c(1,NA),pt.cex = 0.15,lwd = c(NA,2.4), horiz = TRUE)
par(cex.axis=1.3, cex.lab=1.6, cex=1.4, mar=c(5.1, 4.1, 2.1, 2.1), mgp=c(2.3, 0.3, 0),xpd=TRUE, tck = tck_w,font.lab = 2)
plot(data_out$Time,d_out,type = "p",cex = 0.15, xlab = "Time step", ylab = lg, xlim = xl, ylim = yl)
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lwd = 3, col = "red", add = TRUE)
legend("top", c("100 simulations", "average value"), bty = "n", col = c("black","red"),
lty = c(NA,1),pch = c(1,NA),pt.cex = 0.15,lwd = c(NA,2.4), horiz = TRUE)
library(MASS)
df <- data.frame(x=data_out$Time,y=d_out)
# colors
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
r <- rf(40)
# Adjust binning (interpolate - can be computationally intensive for large datasets)
k <- kde2d(df$x, df$y, n=c(300,300))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:99) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend("top", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:99) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
View(df)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:99) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mt-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
kk
k
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], n=c(2,100))
numb
df$x[numb]
df$y[numb]
kde2d(df$x[numb], df$y[numb], n=c(2,100))
k <- kde2d(df$x[numb], df$y[numb], h = 1, n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
k <- kde2d(df$x[numb], df$y[numb], h = 1, n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend("top", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
legend("topright", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = h, n=c(2,100))
k$z <- k$z / max(k$z)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = h, n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend("topright", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(h,1), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(1,h), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend("topright", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
legend("right", c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
legend(x = xl[2]-30, y = yl[2] * 0.9, c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
legend(x = xl[2]-30, y = yl[2] * 0.95, c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
legend(x = xl[2]-30, y = yl[2] * 0.97, c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
ave_plot <- function(data_out, output = "N", lg = "Number of cells", xl, yl) {
mT  <- max(data_out$Time)
mRP <- max(data_out$Repeat_number)
tck_w <- 0.03
par(cex.axis=1.3, cex.lab=1.6, cex=1.4, mar=c(5.1, 4.1, 2.1, 2.1), mgp=c(2.3, 0.3, 0),xpd=TRUE, tck = tck_w,font.lab = 2)
d_out <- data_out[[output]]
# plot(data_out$Time,d_out,type = "p",cex = 0.2)
if (  sum(d_out) == 0) { stop("There are all zero data, please, check input data !") }
data_ave <- matrix(data = 0, ncol = 2,nrow = mT + 1)
for (k in 1:(mT+1)  ) {
data_ave[k,1] = k-1
n <- which(data_out$Time == (k-1) )
data_ave[k,2] = sum(d_out[n]) / mRP
}
plot(data_out$Time,d_out,type = "p",cex = 0.15, xlab = "Time step", ylab = lg, xlim = xl, ylim = yl)
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lwd = 3, col = "red", add = TRUE)
legend("top", c("100 simulations", "average value"), bty = "n", col = c("black","red"),
lty = c(NA,1),pch = c(1,NA),pt.cex = 0.15,lwd = c(NA,2.4), horiz = TRUE)
rd <- readline(prompt= paste0("This is the simple plot for ", lg, " - Press Enter  "))
library(MASS)
df <- data.frame(x=data_out$Time,y=d_out)
# colors
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
r <- rf(40)
# Adjust binning (interpolate - can be computationally intensive for large datasets)
k <- kde2d(df$x, df$y, n=c(300,300))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
#image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = "Number of cells",ylim = c(0,1500))
#axis(3,tck = tck_w,labels = FALSE)
#axis(4,tck = tck_w,labels = FALSE)
#lines(data_ave[2:100,1],data_ave[2:100,2],type = "l",lwd = 2.4, col = "#FF3300")
#levels <- c(min(breaks),0.05,0.1,0.2,0.4,0.6,0.8)
#contour(k, levels = levels, lty = 1 , lwd=0.9, col= "#00EE99", drawlabels = FALSE, add = TRUE)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(1,h), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lty = 1, lwd = 3, col = "#FF00FF")
legend(x = xl[2]-30, y = yl[2] * 0.97, c("average value",""), bty = "n", col = c("#FF00FF",NA),lty = c(1,NA),pch = c(NA,NA),pt.cex = 0.15,lwd = c(4,NA), horiz = TRUE)
}
source(file = "Code/Average_tests.R")
ave_plot(data_out = data_out, output = "N", lg = "Number of cells", xl = c(0,75), yl = c(0,1700))
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
output = "N"
lg = "Number of cells"
xl = c(0,75)
yl = c(0,1700)
data_out <- read.csv("Output/cloneout.txt", sep="\t")
data_out[is.na(data_out)] <- ""
mT  <- max(data_out$Time)
mRP <- max(data_out$Repeat_number)
tck_w <- 0.03
par(cex.axis=1.3, cex.lab=1.6, cex=1.4, mar=c(5.1, 4.1, 2.1, 2.1), mgp=c(2.3, 0.3, 0),xpd=TRUE, tck = tck_w,font.lab = 2)
d_out <- data_out[[output]]
# plot(data_out$Time,d_out,type = "p",cex = 0.2)
if (  sum(d_out) == 0) { stop("There are all zero data, please, check input data !") }
data_ave <- matrix(data = 0, ncol = 2,nrow = mT + 1)
for (k in 1:(mT+1)  ) {
data_ave[k,1] = k-1
n <- which(data_out$Time == (k-1) )
data_ave[k,2] = sum(d_out[n]) / mRP
}
plot(data_out$Time,d_out,type = "p",cex = 0.15, xlab = "Time step", ylab = lg, xlim = xl, ylim = yl)
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
lines(data_ave[1:(mT+1),1],data_ave[1:(mT+1),2],type = "l",lwd = 3, col = "red", add = TRUE)
legend("top", c("100 simulations", "average value"), bty = "n", col = c("black","red"),
lty = c(NA,1),pch = c(1,NA),pt.cex = 0.15,lwd = c(NA,2.4), horiz = TRUE)
rd <- readline(prompt= paste0("This is the simple plot for ", lg, " - Press Enter  "))
library(MASS)
df <- data.frame(x=data_out$Time,y=d_out)
# colors
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
r <- rf(40)
# Adjust binning (interpolate - can be computationally intensive for large datasets)
k <- kde2d(df$x, df$y, n=c(300,300))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(1,h), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(1,h), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, xlab = "Generation number", ylab = lg, ylim = yl, xlim = xl, add = TRUE)
}
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(1,h), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, add = TRUE)
}
axis(3,tck = tck_w,labels = FALSE)
axis(4,tck = tck_w,labels = FALSE)
par(cex.axis=1.3, cex.lab=1.6, cex=1.4, mar=c(5.1, 4.1, 2.1, 2.1), mgp=c(2.3, 0.3, 0),xpd=TRUE, tck = tck_w,font.lab = 2)
image.default(k, col=r, breaks = breaks, xlab = "Time step", ylab = lg, ylim = yl, xlim = xl, legend=TRUE)
# For each time step
for (kk in 1:(mT-1)) {
numb <- which( xor(df$x==kk,df$x==(kk+1)) )
h = ifelse( max(df$y[numb]) - min(df$y[numb]) > 0, max(df$y[numb]) - min(df$y[numb]), 1)
k <- kde2d(df$x[numb], df$y[numb], h = c(1,h), n=c(2,100))
k$z <- k$z / max(k$z)
breaks <- 1:(length(r)+1)
breaks <- breaks / length(r)
image(k, col=r, breaks = breaks, add = TRUE)
}
source(file = "Code/Average_tests.R")
ave_plot(data_out = data_out, output = "N", lg = "Number of cells", xl = c(0,75), yl = c(0,1700))
ave_plot(data_out = data_out, output = "N", lg = "Number of cells", xl = c(0,75), yl = c(0,1800))
getwd()
source(file = "Code/Average_tests.R")
ave_plot(data_out = data_out, output = "N", lg = "Number of cells", xl = c(0,75), yl = c(0,1800))
View(ave_plot)
getwd()
library(stringr)
source(file = "Code/tugHall_clone_functions_tests.R")
mainDir <- getwd()
subDir <- "Output"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Input"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Figures"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
genefile <- 'Input/gene_cds2.txt'    # gene file
clonefile <- 'Input/cloneinit.txt'     # initial Cells
### Output files
geneoutfile <- 'Output/geneout.txt'  # Gene Out file with Hallmarks
cloneoutfile <- 'Output/cloneout.txt'  # output information of simulation
logoutfile <-  'Output/log.txt'      # log file to save the input information of simulation - "log.txt"
E0 <<- 1E-3       # parameter in the division probability
F0 <<- 10        # parameter in the division probability
m0 <<-  1E-9       # mutation probability
uo <<- 0.5        # oncogene mutation probability
us <<- 0.5        # suppressor mutation probability
s0 <<-  10         # parameter in the sigmoid function
k0 <<-  0        # Environmental death probability
### Additional parameters of simulation
censore_n <<- 30000       # Max cell number where the program forcibly stops
censore_t <<- 2         # Max time where the program forcibly stops
##########################################################################################
### Simulation of the cancer cell/clone evolution:
model(genefile, clonefile, geneoutfile, cloneoutfile, logoutfile, E0, F0, m0, uo, us, s0, k0, censore_n, censore_t)
library(stringr)
source(file = "Code/tugHall_clone_functions.R")
mainDir <- getwd()
subDir <- "Output"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Input"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Figures"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
genefile <- 'Input/gene_cds2.txt'    # gene file
clonefile <- 'Input/cloneinit.txt'     # initial Cells
### Output files
geneoutfile <- 'Output/geneout.txt'  # Gene Out file with Hallmarks
cloneoutfile <- 'Output/cloneout.txt'  # output information of simulation
logoutfile <-  'Output/log.txt'      # log file to save the input information of simulation - "log.txt"
E0 <<- 1E-3       # parameter in the division probability
F0 <<- 10        # parameter in the division probability
m0 <<-  1E-9       # mutation probability
uo <<- 0.5        # oncogene mutation probability
us <<- 0.5        # suppressor mutation probability
s0 <<-  10         # parameter in the sigmoid function
k0 <<-  0        # Environmental death probability
### Additional parameters of simulation
censore_n <<- 30000       # Max cell number where the program forcibly stops
censore_t <<- 2         # Max time where the program forcibly stops
##########################################################################################
### Simulation of the cancer cell/clone evolution:
model(genefile, clonefile, geneoutfile, cloneoutfile, logoutfile, E0, F0, m0, uo, us, s0, k0, censore_n, censore_t)
getwd()
library(stringr)
source(file = "Code/tugHall_clone_functions.R")
## Create folders:  /Input, /Output and /Figures
mainDir <- getwd()
subDir <- "Output"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Input"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Figures"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
##########################################################################################
### Files to output and input data
genefile <- 'Input/gene_cds2.txt'    # gene file
clonefile <- 'Input/cloneinit.txt'     # initial Cells
### Output files
geneoutfile <- 'Output/geneout.txt'  # Gene Out file with Hallmarks
cloneoutfile <- 'Output/cloneout.txt'  # output information of simulation
logoutfile <-  'Output/log.txt'      # log file to save the input information of simulation - "log.txt"
### Output/Weights.txt               # file with gene weights for hallmarks
##########################################################################################
# Probabilities of processes
E0 <<- 1E-3       # parameter in the division probability
F0 <<- 10        # parameter in the division probability
m0 <<-  1E-9       # mutation probability
uo <<- 0.5        # oncogene mutation probability
us <<- 0.5        # suppressor mutation probability
s0 <<-  10         # parameter in the sigmoid function
k0 <<-  0        # Environmental death probability
### Additional parameters of simulation
censore_n <<- 30000       # Max cell number where the program forcibly stops
censore_t <<- 2         # Max time where the program forcibly stops
##########################################################################################
### Simulation of the cancer cell/clone evolution:
model(genefile, clonefile, geneoutfile, cloneoutfile, logoutfile, E0, F0, m0, uo, us, s0, k0, censore_n, censore_t)
##########################################################################################
#### Analysis of the output data:
# See the output file: clonout.txt
library(stringr)
source(file = "Code/tugHall_clone_functions.R")
mainDir <- getwd()
subDir <- "Output"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Input"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Figures"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
genefile <- 'Input/gene_cds2.txt'    # gene file
clonefile <- 'Input/cloneinit.txt'     # initial Cells
### Output files
geneoutfile <- 'Output/geneout.txt'  # Gene Out file with Hallmarks
cloneoutfile <- 'Output/cloneout.txt'  # output information of simulation
logoutfile <-  'Output/log.txt'      # log file to save the input information of simulation - "log.txt"
E0 <<- 1E-3       # parameter in the division probability
F0 <<- 10        # parameter in the division probability
m0 <<-  1E-9       # mutation probability
uo <<- 0.5        # oncogene mutation probability
us <<- 0.5        # suppressor mutation probability
s0 <<-  10         # parameter in the sigmoid function
k0 <<-  0        # Environmental death probability
### Additional parameters of simulation
censore_n <<- 30000       # Max cell number where the program forcibly stops
censore_t <<- 2         # Max time where the program forcibly stops
##########################################################################################
### Simulation of the cancer cell/clone evolution:
model(genefile, clonefile, geneoutfile, cloneoutfile, logoutfile, E0, F0, m0, uo, us, s0, k0, censore_n, censore_t)
##########################################################################################
# See the output file: clonout.txt
# See the output file: clonout.txt
getwd()
##########################################################################################
###  The simulation uses the functions and classes in the "Code/tugHall_2.1_functions.R"
library(stringr)   # to use string data in input files
library(actuar)    # to use BIG NUMBERS in N_cell variable
source(file = "Code/tugHall_2.1_functions.R")
## Create folders:  /Input, /Output and /Figures
mainDir <- getwd()
subDir <- "Output"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Input"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
subDir <- "Figures"
if (! file.exists(subDir)){  dir.create(file.path(mainDir, subDir)) }
##########################################################################################
### Files to output and input data
genefile <- 'Input/gene_cds2.txt'    # gene file
clonefile <- 'Input/cloneinit.txt'     # initial Cells
### Output files
geneoutfile <- 'Output/geneout.txt'  # Gene Out file with Hallmarks
cloneoutfile <- 'Output/cloneout.txt'  # output information of simulation
logoutfile <-  'Output/log.txt'      # log file to save the input information of simulation - "log.txt"
### Output/Weights.txt               # file with gene weights for hallmarks
##########################################################################################
# Probabilities of processes
E0 <<-  1E-3       # parameter in the division probability
F0 <<-  10         # parameter in the division probability
m0 <<-  1E-9       # mutation probability
uo <<-  0.5        # oncogene mutation probability
us <<-  0.5        # suppressor mutation probability
s0 <<-  10         # parameter in the sigmoid function
k0 <<-  0        # Environmental death probability
d0 <<-  0   # Initial probability to divide cells
### Additional parameters of simulation
censore_n <<- 10^4       # Max cell number where the program forcibly stops
censore_t <<- 2         # Max time where the program forcibly stops
##########################################################################################
### Simulation of the cancer cell/clone evolution:
model(genefile, clonefile, geneoutfile, cloneoutfile, logoutfile, E0, F0, m0, uo, us, s0, k0, censore_n, censore_t, d0)
